```{r theHeader, echo=FALSE, results='asis'}
Pmisc::markdownHeader(
title= "Population-weighted exposure to air pollution and COVID-19 infection in Germany",
author="Guowen Huang$^{1,2,*}$, Patrick E Brown$^{1,2}$", date = "",
fontsize=12, bibliography='thebib.bib', headerincludes = c('\\usepackage{xcolor}','\\usepackage{setspace}\\doublespacing','\\usepackage{pdflscape}','\\usepackage{float}','\\usepackage{booktabs}','\\newcommand{\\tp}{^\\text{T}}','\\newcommand{\\dens}{\\boldsymbol{\\pi}}','\\usepackage[a4paper,width=15cm, lines=26, left=3cm ]{geometry}'))
```

    
     

```{r setup, include=FALSE, cache.comments=FALSE}
knitr::opts_chunk$set(echo = FALSE, error=FALSE, cache.comments=FALSE,
  fig.pos="H", cache.lazy = FALSE, fig.cap = " ", message=FALSE, warning=FALSE, dev='png', dpi=300, margins=1,
   fig.width=6, fig.height=4)

  knitr::knit_hooks$set(plot=knitr::hook_plot_tex)  
 
 knitr::knit_hooks$set(
  margins = function (before, options, envir) {
    if (!before) 
        return()
    graphics::par(
      mar = c(1.5 + 0.9 * options$margins, 
        1.7 + 0.9 * options$margins, 0.2, 0.2), 
    mgp = c(1.45, 0.45, 0), cex = 1.25, bty='n')
})
```


   
 
```{r packageAndConstant, include=FALSE}
library(rstan)
library(robustbase)
library(data.table)
library(lubridate)
library(dplyr)
library(sp)
library(rgdal)
library(here)
library(INLA)
library(Epi)
library(survival)
library(denstrip)
library(MASS) 

load(here::here("Paper","Covid19","Germany","resultTable.RData"))

libs <- c('dplyr', 'tibble',      # wrangling
          'stringr', 'readr',     # strings, input
          'lubridate', 'tidyr',   # time, wrangling
          'knitr', 'kableExtra',  # table styling
          'ggplot2', 'viridis',   # visuals
          'gganimate', 'sf',      # animations, maps
          'ggthemes')             # visuals
invisible(lapply(libs, library, character.only = TRUE))

```



## Abstract{-}

It is well known that COVID-19, caused by the severe acute respiratory syndrome coronavirus 2 (SARS-CoV-2), is to spread mainly from person to person, mainly through respiratory droplets produced when an infected person coughs or sneezes. Therefore, many countries have enforced social distancing to stop the spread of COVID-19. Within countries, although the measures taken by governments are similar, the incidence rate varies among areas (e.g., counties, cities). One potential explanation is that people in some areas are more vulnerable to the coronavirus disease because of their worsen health conditions caused by long-term exposure to poor air quality. In this study, we investigate whether long-term exposure to air pollution increases the risk of COVID-19 infection in Germany. The results show that nitrogen dioxide (NO$_2$) is significantly associated with COVID-19 incidence rate, with 1 $\mu gm^{-3}$ increase of long-term exposure to NO$_2$, the COVID-19 incidence rate is likely to increase `r substring(resultTable[1,1], 3, 6)`\% (95% credible interval [CI]: `r substring(resultTable[1,2], 3, 7)`\%, `r substring(resultTable[1,2], 11, 15)`\%). This result is consistent across various health models. The analyses can be reproduced and updated routinely using public data sources and shared R code.

## Keywords{-}
COVID-19, air pollution, health impacts, Kriging, INLA

## Author information{-}

$^1$ Dept. of Statistical Sciences, University of Toronto, Toronto, ON, Canada  
$^2$ Centre for Global Health Research, St Michael's Hospital, Toronto, ON, Canada  
$^*$ Corresponding author: E-mail: hgw0610209\@gmail.com

 
# Introduction
 
COVID-19, caused by the severe acute respiratory syndrome coronavirus 2 (SARS-CoV-2), is currently widespread and much more dangerous than seasonal flu. COVID-19 is more infectious than seasonal flu and has a higher death rate. Up to 17th September, 2020, it has led to worldwide over 30.3 million cases and 950 thousand deaths. In Germany, the total confirmed cases up to 17th September, 2020 have risen to 269 thousand, with deaths being more than 9.4 thousand. A recent study by @Wu2020 investigated the impact of long-term average exposure to fine particulate matter (PM$_{2.5}$) on the risk of COVID-19 deaths in the United States and found that an increase of only 1 $\mu g/m^{-3}$ in PM$_{2.5}$ was associated with a 8\% (95\% confidence interval, 2\%, 15\%) increase in the COVID-19 death rate. @Ogen2020 reported that most of COVID-19 fatality cases occurred in those regions with the highest NO$_2$ concentrations while studying 66 administrative regions in Italy, Spain, France and Germany. These results suggest that high levels of air pollution may be an important contributor to COVID-19 infections or deaths. 

## Literature review on epidemiology 

The existing body of research on the impacts of air pollution on human health, has linked PM$_{2.5}$ and NO$_2$ exposure to health damage, particularly respiratory and lung diseases, which could make people more vulnerable to contracting COVID-19. The main source of NO$_2$ resulting from human activities is the combustion of fossil fuels (coal, gas and oil), especially fuel used in cars. Exposure to high levels of NO$_2$ can cause inflammation of the airways. Long-term exposure may affect lung function and respiratory symptoms. For example, the research results from @Bowatte2017 indicate that long-term exposure to NO$_2$ was associated with increased risk of respiratory diseases, while @Lee2009 show that long-term exposure to NO$_{2}$ was significantly associated with respiratory hospital admissions in Edinburgh and Glasgow, UK. Similarly, @Schikowski2005 suggests that long-term exposure to air pollution from NO$_2$ and living near a major road might increase the risk of developing chronic obstructive pulmonary disease (COPD) and can have a detrimental effect on lung function. 

On the other hand, particulate matter (both PM$_{10}$ and PM$_{2.5}$) is made up of a wide range of materials and arises from both human-made (such as stationary fuel combustion and transport) and natural sources (such as sea spray and Saharan sand dust). Concentrations of particulate matter comprises primary particles emitted directly into the atmosphere from combustion sources and secondary particles formed by chemical reactions in the air. Exposure to particulate matter is associated with respiratory and cardiovascular illness and mortality as well as other adverse health effects. Since the particulate matter can be inhaled into the thoracic region of the respiratory tract, there is a plausible reason the relationship could be causal. Examples include @Lee2009 and @Lee2012b, where the authors found that long-term exposure to PM$_{10}$ was significantly associated with respiratory hospital admissions.  Recent reviews by @COMEAP2010 have suggested exposure to PM$_{2.5}$ had a stronger association with the observed adverse health effects because they can travel deeper into lungs. 

## Literature review on statistical models

A spatial ecological design can be used to estimate the impacts of air pollution on health by comparing geographical contrasts in air pollution and infection risk across $K$ contiguous small areas [@Huang2018; @Napier2018; @Rushworth2014]. In such studies, the disease data are counts of disease cases occurring in each areal unit while the spatially representative pollution concentrations in each areal unit are typically estimated by applying Kriging, a spatial model [@Diggle2007], to data from a sparse monitoring network, or by computing averages over modelled concentrations (grid level) from an atmospheric dispersion model [@Wu2020; @Maheswaran2006; @Lee2009; @Warren2012a], or by combining both to obtain a better prediction [@Huang2018; @VinikoorImler2014; @Sacks2014]. The downside of these studies is that the inference is a population level association rather than an individual-level causal relationship, and wrongly assuming the two are the same is known as ecological bias [@Arbia1988; @Wakefield2001]. Such bias is due in part to within-population variation in pollution exposures and disease incidence, because one does not know whether, within a population, it is the same individuals that exhibit disease and have the highest air pollution exposures [@Lee2020]. The simulation study from @Lee2020 also suggests that the estimates of the aggregated model from individual levels almost always exhibit less variation than those from the ecological model.

Another challenge in air pollution health effect studies is how to allow for the uncertainty in the estimated pollution concentrations when estimating their health effects [@Huang2018; @Blair2007]. Specifically, the areal level pollution predictions produced from the pollution data are with uncertainty as they are only the estimates of the true spatially-varying concentrations. The disadvantage of using a point estimate is that one may overstate the certainty about the connection between the outcome and the covariate. A number of approaches have been proposed to incorporate pollution uncertainties and measurement errors into the health model [e.g., @Huang2018; @Lee2017; @Blangiardo2016; @Gryparis2009].

In this study, we investigate whether long-term average exposure to air pollution increases the risk of COVID-19 infection in Germany using a spatial ecological design. Specifically, in order to reduce the potential ecological bias, we better estimate the real areal pollution concentrations by first using Kriging to pollution monitoring data to obtain predictions on fine grids where population density data are available, then estimate the areal pollution concentrations by taking spatially population-weighted average of the gridded predictions lying within a specific county. This will likely enhance the estimation of people's real exposure for those counties where they generally live at rural areas while their urban pollution are much worse compared to the rural areas. Given that the study from @Lee2017 showed that treating the posterior predictive pollution distribution as a prior in the disease model has produced similar results to ignoring the uncertainty except for PM$_{10}$, and @Blangiardo2016 also found that incorporating uncertainty in pollution by making multiple sets of estimated exposure and then fitting the disease model separately for each set before combining the estimated health effects, did not change the substantive conclusions, we do not address exposure uncertainty in this study. Instead, we incorporate the reliability of gridded pollution predictions while aggregating them spatially, with details can be found in Section \ref{sec:weightedexposure}.

The remainder of this paper is organized as follows. The data and its exploratory analysis are presented in Section \ref{sec:studyRegion}, while the statistical methodology is outlined in Section \ref{sec:method}. The results of the study are reported in Section \ref{sec:results}, and the key conclusions are presented in Section \ref{sec:conclusion}.

# Study region {#sec:studyRegion}

The study region is Germany which has a population of around 83 million people and $K=401$ counties (administrative districts), among which 294 are rural and 107 are urban. A map of these counties is shown in Figure \ref{fig:maps}, showing boundaries obtained from Germany's Federal Agency for Cartography and Geodesy [@BKG2020]. 

## Data description

The data set used in this study include COVID-19 cases, pollution concentrations, temperature and population data. The accumulated COVID-19 cases used in this study are collected up to 2020-09-13 at the county-level. Both pollution and temperature data are the most recent available few years (2016-2018) average concentrations (representing long-term exposure) from monitoring sites, which are converted to county-level by applying the spatial modelling and prediction method described in Section \ref{sec:method} to obtain the spatially population-weighted representative concentrations for each county. The pollutants considered in this study include common pollutants: PM$_{2.5}$ and PM$_{10}$, NO$_{2}$, SO$_2$; and also four poisonous pollutants: benzene, arsenic in PM$_{10}$, cadmium in PM$_{10}$ and nickel in PM$_{10}$. These pollutants could have potential harmful health effects, such as damage to the lungs and nasal cavity, reducing lung function, causing chronic bronchitis and cancers of the bladder and lungs [@Yu2002; @Smith2010; @Jarup1998; @Das2008]. 

The population data contain fine gridded population density data, the population by sex and age on the federal state level and also the county level population data. The fine gridded population density data are used for calculating population-weighted county level exposure (see Section \ref{sec:method} for details), while the latter two are used to calculate the expected number of cases in each county. Specifically, we denote Y$_k$ as the reported numbers of COVID-19 cases for county $k$, and calculate the expected number of cases in each county by $E_k=\frac{P_k}{P_{s(k)}} \sum_j r_j P_{s(k),j}$, where $P_k$ is the population in county $k$, $r_j$ is the national incidence rate in sex-age group $j$, and $P_{s(k)}= \sum_jP_{s(k),j}$ denotes the population of the state which contains county $k$. The latter part in the equation $\sum_j r_j P_{s(k),j}$ is the expected cases in state $s(k)$. Then we use standardized incidence ratio (SIR) given by SIR$_{k}=Y_{k}/E_{k}$, to measure the risk of disease, and an SIR of 1.1 indicates a 10$\%$ increased risk of disease compared to that expected. A spatial map of the natural logarithm of SIR for COVID-19 (the scale will be modelled on) as of 2020-09-13 can be seen in Figure \ref{fig:maps3}, showing a wide variation in SIRs across the counties in Germany and the majority of the high‐risk counties are at the east and south part of Germany.  

## Data sources

The COVID-19 cases by county, and the population by sex and age on the federal state level in Germany are publicly available on Kaggle [@HeadsorTails2020], where the COVID-19 cases and deaths will be updated daily, with the earliest recorded cases are from 2020-01-24. More details on the original sources of COVID-19 and state level population data can be found in @HeadsorTails2020. The county level population data are freely obtained from the City Population [@Citypopulation2019]. Both two population data sets reflect the (most recent available) estimates on 2018-12-31. The fine gridded population density data are freely available on DIVA-GIS [@DIVAGIS2020], which is shown in Figure \ref{fig:maps2}.

Pollution data are available from the Air Quality e-Reporting provided by European Environment Agency [@EEA2020], where the monitoring stations are shown in Figure \ref{fig:maps1} which tend to be dense where the population density is high (see Figure \ref{fig:maps2}). The monitoring temperature data can be freely downloaded from European Climate Assessment \& Dataset [@ECAD2020]. 

```{r library, eval=F}
#https://www.kaggle.com/headsortails/covid19-tracking-germany
libs <- c('dplyr', 'tibble',      # wrangling
          'stringr', 'readr',     # strings, input
          'lubridate', 'tidyr',   # time, wrangling
          'knitr', 'kableExtra',  # table styling
          'ggplot2', 'viridis',   # visuals
          'gganimate', 'sf',      # animations, maps
          'ggthemes')             # visuals
invisible(lapply(libs, library, character.only = TRUE))

infile <- "https://opendata.arcgis.com/datasets/dd4580c810204019a7b8eb3e0b329dd6_0.csv"
covid_de <- read_csv(infile, col_types = cols())


covid_de <- covid_de %>% 
  dplyr::select(state = Bundesland,
         county = Landkreis,
         age_group = Altersgruppe,
         gender = Geschlecht,
         cases = AnzahlFall,
         deaths = AnzahlTodesfall,
         recovered = AnzahlGenesen,
         date = Meldedatum) %>% 
  mutate(date = date(date)) %>% 
  mutate(age_group = str_remove_all(age_group, "A")) %>% 
  mutate(age_group = case_when(
    age_group == "unbekannt" ~ NA_character_,
    age_group == "80+" ~ "80-99",
    TRUE ~ age_group
  )) %>% 
  mutate(gender = case_when(
    gender == "W" ~ "F",
    gender == "unbekannt" ~ NA_character_,
    TRUE ~ gender
  )) %>% 
  group_by(state, county, age_group, gender, date) %>% 
  summarise(cases = sum(cases),
            deaths = sum(deaths),
            recovered = sum(recovered)) %>% 
  ungroup() %>% 
  filter(cases >= 0 & deaths >= 0) %>%
  filter(date < today()) %>% 
  mutate(state = str_replace_all(state, "ü", "ue")) %>% 
  mutate(state = str_replace_all(state, "ä", "ae")) %>% 
  mutate(state = str_replace_all(state, "ö", "oe")) %>% 
  mutate(state = str_replace_all(state, "ß", "ss")) %>% 
  mutate(county = str_replace_all(county, "ü", "ue")) %>% 
  mutate(county = str_replace_all(county, "ä", "ae")) %>% 
  mutate(county = str_replace_all(county, "ö", "oe")) %>% 
  mutate(county = str_replace_all(county, "ß", "ss")) %>% 
  mutate(county = str_remove(county, "\\(.+\\)")) %>% 
  mutate(county = str_trim(county)) %>% dplyr::filter(!is.na(age_group))%>% dplyr::filter(!is.na(gender))

shape_county <- st_read(here::here("Paper","Covid19","Germany","covid19-tracking-germany", "de_county.shp"), quiet = TRUE) %>% rename(county = GEN) %>% 
  dplyr::select(county, BEZ, geometry) %>% 
  mutate(county = as.character(county)) %>% 
  mutate(county = str_replace_all(county, "ü", "ue")) %>% 
  mutate(county = str_replace_all(county, "ä", "ae")) %>% 
  mutate(county = str_replace_all(county, "ö", "oe")) %>% 
  mutate(county = str_replace_all(county, "ß", "ss")) %>% 
  mutate(county = str_remove(county, "\\(.+\\)")) %>% 
  mutate(county = str_trim(county)) %>% 
  mutate(BEZ = case_when(
    BEZ == "Kreis" ~ "LK",
    BEZ == "Landkreis" ~ "LK",
    BEZ == "Stadtkreis" ~ "SK",
    BEZ == "Kreisfreie Stadt" ~ "SK"
  )) %>% 
  unite(county, BEZ, county, sep = " ", remove = TRUE) %>% group_by(county) %>% summarize()
  
  # split(.$county) %>% 
  # lapply(st_union) %>% 
  # do.call(c, .) %>% st_sf()

foo <- covid_de %>% 
  mutate(county = case_when(
    county == "Region Hannover" ~ "LK Region Hannover",
    county == "SK Muelheim a.d.Ruhr" ~ "SK Muelheim an der Ruhr",
    county == "StadtRegion Aachen" ~ "LK Staedteregion Aachen",
    county == "SK Offenbach" ~ "SK Offenbach am Main",
    county == "LK Bitburg-Pruem" ~ "LK Eifelkreis Bitburg-Pruem",
    county == "SK Landau i.d.Pfalz" ~ "SK Landau in der Pfalz",
    county == "SK Ludwigshafen" ~ "SK Ludwigshafen am Rhein",
    county == "SK Neustadt a.d.Weinstrasse" ~ "SK Neustadt an der Weinstrasse",
    county == "SK Freiburg i.Breisgau" ~ "SK Freiburg im Breisgau",
    county == "LK Landsberg a.Lech" ~ "LK Landsberg am Lech",
    county == "LK Muehldorf a.Inn" ~ "LK Muehldorf a. Inn",
    county == "LK Pfaffenhofen a.d.Ilm" ~ "LK Pfaffenhofen a.d. Ilm",
    county == "SK Weiden i.d.OPf." ~ "SK Weiden i.d. OPf.",
    county == "LK Neumarkt i.d.OPf." ~ "LK Neumarkt i.d. OPf.",
    county == "LK Neustadt a.d.Waldnaab" ~ "LK Neustadt a.d. Waldnaab",
    county == "LK Wunsiedel i.Fichtelgebirge" ~ "LK Wunsiedel i. Fichtelgebirge",
    county == "LK Neustadt a.d.Aisch-Bad Windsheim" ~ "LK Neustadt a.d. Aisch-Bad Windsheim",
    county == "LK Dillingen a.d.Donau" ~ "LK Dillingen a.d. Donau",
    county == "LK Stadtverband Saarbruecken" ~ "LK Regionalverband Saarbruecken",
    county == "LK Saar-Pfalz-Kreis" ~ "LK Saarpfalz-Kreis",
    county == "LK Sankt Wendel" ~ "LK St. Wendel",
    county == "SK Brandenburg a.d.Havel" ~ "SK Brandenburg an der Havel",
    str_detect(county, "Berlin") ~ "SK Berlin",
    TRUE ~ county
  ))  
  
  stateAndCounty <- foo %>% dplyr::select(state,
         county) %>% unique()
  
 foo=foo%>% group_by(county, date) %>% 
  summarise(
             cases = sum(cases),
            deaths = sum(deaths)) %>% 
  ungroup() %>% 
  complete(county, date, fill = list(cases = 0, deaths = 0)) %>% 
  group_by(county) %>% 
  mutate(cumul_cases = cumsum(cases),
         cumul_deaths = cumsum(deaths)) %>% 
  ungroup() %>%  dplyr::filter(date==max(date))

shape_county <- shape_county %>% dplyr::left_join(foo, by="county") %>% dplyr::left_join(stateAndCounty, by="county")


population_state <- read.csv(here::here("Paper","Covid19","Germany","covid19-tracking-germany", "demographics_de.csv"))

# https://www.citypopulation.de/en/germany/admin/
population_de_table <- read.csv(here::here("Paper","Covid19","Germany", "population_de_table.csv")) %>% dplyr::filter(str_detect(Status, "County")) %>% 
  mutate(Name = str_replace_all(Name, "ü", "ue")) %>% 
  mutate(Name = str_replace_all(Name, "ä", "ae")) %>% 
  mutate(Name = str_replace_all(Name, "ö", "oe")) %>% 
  mutate(Name = str_replace_all(Name, "ß", "ss")) %>% 
  mutate(Name=gsub("\\s*\\([^\\)]+\\)","",Name)) %>% transmute(Name=Name, population=Population.Estimate.2018.12.31)

population_de_table$Name[grep("Heidekreis", population_de_table$Name)] <- "Heidekreis"
population_de_table$Name[grep("Bitburg-Pruem", population_de_table$Name)] <- "Eifelkreis Bitburg-Pruem"

library(stringr)
shape_county$stateShort=str_sub(shape_county$county,1,2)
shape_county$county=str_sub(shape_county$county,4,-1)

shape_county <- shape_county %>% dplyr::left_join(population_de_table, by=c("county"="Name"))

rate_de <- covid_de %>% group_by(age_group,gender) %>% summarise(totalCase=sum(cases,na.rm = TRUE)) 
pop_agg_state <- population_state %>% group_by(age_group, gender) %>% summarise(sumPop=sum(population)) 
rate_de$incidenceRate=rate_de$totalCase/pop_agg_state$sumPop

new_population_state <-  population_state%>% group_by(state,age_group, gender) %>% summarise(sumPop=sum(population)) 
new_population_state$e <- new_population_state$sumPop*rate_de$incidenceRate
new_population_state <- new_population_state %>% group_by(state) %>% summarise(E_state=sum(e))

pop_state <- shape_county %>% dplyr::group_by(state) %>% summarise(pop_state=sum(population)) %>% as.data.frame()

shape_county <- shape_county %>% dplyr::left_join(new_population_state, by="state") %>% dplyr::left_join(pop_state,by="state")
shape_county <- shape_county %>% mutate(E=E_state*population/pop_state) %>% dplyr::select(-cases, -deaths)
shape_county <- shape_county %>% mutate(popDensity=population/st_area(shape_county))
  

save(shape_county, file=here::here("Paper","Covid19","Germany", "shape_country.RData"))
```

```{r maps, fig.cap="Pollution stations, population density, log COVID-19 SIR and population-weighted NO$_2$ ($\\mu g m^{-3}$) in Germany.",fig.subcap=c("Pollution stations","Population density", "log(SIR) in counties", "NO$_2$ in counties"), fig.width=8, fig.height=6, out.width=Pmisc::out.width(0.5), dev='pdf'}
# http://aidef.apps.eea.europa.eu/tools/download/data.csv
# http://aidef.apps.eea.europa.eu/?source=%7B%22query%22%3A%7B%22match_all%22%3A%7B%7D%7D%2C%22display_type%22%3A%22tabular%22%7D
# Air Quality e-Reporting provided by European Environment Agency (EEA)
#https://www.eea.europa.eu/data-and-maps/data/aqereporting-8
library(sp)
library(rgdal)
library(dplyr)
country="Germany"

EuropPol <- read.csv(file = here::here("Paper","Covid19","longTerm","Italy","data.csv")) %>% dplyr::filter(stringr::str_detect(ReportingYear,"2016|2017|2018"),CountryOrTerritory==country) 

# topTen <- EuropPol%>% 
#   group_by(Pollutant) %>% summarise(count=n()) %>% dplyr::top_n(10)

cityPol <- EuropPol 
# %>% dplyr::filter(Pollutant %in% topTen$Pollutant)

weather_station <- cityPol %>% 
    rename(lat = SamplingPoint_Latitude) %>%
    rename(long = SamplingPoint_Longitude)

  coordinates(weather_station) <- c('long','lat')
  proj4string(weather_station) <- CRS('+proj=longlat +ellps=WGS84')
   weather_station <- remove.duplicates(weather_station)
 
   de_map <- raster::getData('GADM', country="DE", level=0)
   
plot(de_map)
points(weather_station, pch=".", col="black", cex=2.5)

   cityPop <- raster::raster(here::here("Paper","Covid19","MedalComponents",paste0("DEU","_msk_pop"),paste0(tolower("DEU"), "_msk_pop")))
 spplot(cityPop, col="transparent", 
       col.regions=gray.colors(20, start = 0.9, end = 0.3, gamma = 2.2, alpha = NULL),
       colorkey = list(labels = list( cex = 1.5)))
 
load(file=here::here("Paper","Covid19","Germany", "Final_shp.RData"))
Final_shp@data %>% mutate(logSIR=log(cumul_cases/E), SIR=cumul_cases/E)->Final_shp@data


spplot(Final_shp,"logSIR", col="transparent", 
       col.regions=gray.colors(20, start = 0.9, end = 0.3, gamma = 2.2, alpha = NULL),
       colorkey = list(labels = list( cex = 1.5)))

spplot(Final_shp,"no2", col="transparent", 
       col.regions=gray.colors(20, start = 0.9, end = 0.3, gamma = 2.2, alpha = NULL),
       colorkey = list(labels = list( cex = 1.5)))

```


```{r KrigingPollutionData, eval=FALSE}
library(gstat)
library(geoR)
library(maps)
library(raster)
library(ggplot2)

getKrigingPolforShp <- function(countyname, shortcode,polPattern,existShp, polName)
{
  
city_pol <- EuropPol %>% dplyr::filter(CountryOrTerritory==countyname,str_detect(Pollutant,polPattern))%>% group_by(StationLocalId) %>% summarize( long=mean(SamplingPoint_Longitude,na.rm = T),lat=mean(SamplingPoint_Latitude,na.rm = T),
  meanP=median(AQValue,na.rm = T)) %>% dplyr::filter(meanP< quantile(meanP, c(0.95)))

city <- map_data("world") %>% filter(region==countyname)

# ggplot() +
#   geom_polygon(data = city, aes(x=long, y = lat, group = group), fill="grey", alpha=0.3) +
#   geom_point( data=city_pol, aes(x=long, y=lat, alpha=meanP)) +
#   scale_size_continuous(range=c(1,12)) +
#   theme_void() + coord_map()

##kriging
s100 <-  city_pol%>% group_by(long,lat) %>% summarize(meanPP=mean(meanP)) #duplicated coordinates
s100 <- as.geodata(s100)
# ml <- likfit(s100, ini = c(1,0.5), fix.nugget = T)
ml <- likfit(s100, ini = c(1,0.5), nug = 0.5)

# bsp4 <- krige.bayes(s100, loc = new.loc, prior = prior.control(phi.discrete = seq(0,5,l=101), phi.prior="rec"), output=output.control(n.post=5000))
# defining the grid
#-----------------------------------------------------------------
# ## grid from polygon
#   library(sp)
#   library(raster)
#   ItalyPolygon = getData(name="GADM",country="Italy", level=0)
# 
#   pred.grid <-  expand.grid(x=seq(5,20, l=200), y=seq(35,50, l=200))
#   coordinates(pred.grid) = ~x+y
# projection(pred.grid)="+init=epsg:4326" # code for lat-long
# 
# projection(ItalyPolygon)=projection(pred.grid) # everything is lat-long
# inItaly = !is.na(over(pred.grid, as(ItalyPolygon,"SpatialPolygons")))
# plot(ItalyPolygon)
# plot(pred.grid[inItaly,],add=TRUE)
# 
# new.loc <- pred.grid[inItaly,]
# new.loc <- as.data.frame(new.loc)
#-----------------------------------------------------------------
# https://www.diva-gis.org/gdata
cityPop <- raster::raster(here::here("Paper","Covid19","MedalComponents",paste0(shortcode,"_msk_pop"),paste0(tolower(shortcode), "_msk_pop")))
new.loc <- as.data.frame(coordinates(cityPop))
# kriging calculations
kc <- krige.conv(s100, loc = new.loc, krige = krige.control(obj.m = ml, ty="ok"))
# displaying predicted values

# lalala <- cbind(new.loc, value=kc$predict, inver_sd=1/(sqrt(kc$krige.var)))
lalala <- cbind(new.loc, value=kc$predict, inver_sd=1/((kc$krige.var)))
# 
# ggplot() +
#     geom_polygon(data = city, aes(x=long, y = lat, group = group), fill="grey", alpha=0.3) +
#     geom_point( data=lalala, aes(x=x, y=y, color=value)) +
#     theme_void() + coord_map()

# consider variance
cityPop <- cityPop*lalala$inver_sd

PPmultiply <- cityPop*lalala$value

# get the grid within each prov
# shp <- raster::shapefile(here::here("Paper","Covid19","MedalComponents",paste0(shortcode,"_adm"),paste0(shortcode, "_adm2")))
rasterGrid_list <- vector(mode="list",length = length(existShp))

## Make Weather Station a Spatial Object
  weather_station <- coordinates(cityPop)
  weather_station <- as.data.frame(weather_station)
  colnames(weather_station) <- c('long','lat')
  coordinates(weather_station) <- c('long','lat')
projection(weather_station)="+init=epsg:4326" # code for lat-long

# get stations within Province
for(i in 1:length(rasterGrid_list))
{
  # Just try to make Toronto work 
  ## Projection and Buffer
  toronto = existShp[i,]
  ## Project weather station 
projection(toronto)=projection(weather_station) # everything is lat-long
insideTO = !is.na(over(weather_station, as(toronto,"SpatialPolygons")))
  rasterGrid_list[[i]] <- which(insideTO)
  print(i)
}

 # plot(shp[4,])
 # plot(weather_station[rasterGrid_list[[4]]], add=TRUE)

existShp@data$newVar <- NA
for(i in 1:length(rasterGrid_list))
{
existShp@data$newVar[i] <- 
sum(values(PPmultiply)[rasterGrid_list[[i]]]/sum(values(cityPop)[rasterGrid_list[[i]]],na.rm = TRUE),na.rm = T)
}
names(existShp@data)[length(names(existShp@data))] <- polName
####
return(list(existShp=existShp,ml=ml))
}

GermanyShp <- st_transform(shape_county, "+proj=longlat +datum=WGS84") 
GermanyShp <- as(shape_county,"Spatial")
GermanyShp <- spTransform(GermanyShp, "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")

polParameterList <- vector(mode="list", length=10)

temp <- getKrigingPolforShp(countyname="Germany", shortcode="DEU",polPattern="Nitrogen dioxide",existShp=GermanyShp, polName="no2")
Final_shp <- temp$existShp
polParameterList[[1]] <- temp$ml

temp <- getKrigingPolforShp(countyname="Germany", shortcode="DEU",polPattern="2.5 µm",existShp=Final_shp, polName="pm25")
Final_shp <- temp$existShp
polParameterList[[2]] <- temp$ml

temp <- getKrigingPolforShp(countyname="Germany", shortcode="DEU",polPattern="10 µm",existShp=Final_shp, polName="pm10")
Final_shp <- temp$existShp
polParameterList[[3]] <- temp$ml

temp <- getKrigingPolforShp(countyname="Germany", shortcode="DEU",polPattern="Ozone",existShp=Final_shp, polName="o3")
Final_shp <- temp$existShp
polParameterList[[4]] <- temp$ml

temp <- getKrigingPolforShp(countyname="Germany", shortcode="DEU",polPattern="Sulphur dioxide",existShp=Final_shp, polName="so2")
Final_shp <- temp$existShp
polParameterList[[5]] <- temp$ml

temp <- getKrigingPolforShp(countyname="Germany", shortcode="DEU",polPattern="Benzene",existShp=Final_shp, polName="Benzene")
Final_shp <- temp$existShp
polParameterList[[6]] <- temp$ml

temp <- getKrigingPolforShp(countyname="Germany", shortcode="DEU",polPattern="Arsenic",existShp=Final_shp, polName="Aresenic")
Final_shp <- temp$existShp
polParameterList[[7]] <- temp$ml

temp <- getKrigingPolforShp(countyname="Germany", shortcode="DEU",polPattern="Cadmium",existShp=Final_shp, polName="Cadmium")
Final_shp <- temp$existShp
polParameterList[[8]] <- temp$ml

temp <- getKrigingPolforShp(countyname="Germany", shortcode="DEU",polPattern="Nickel",existShp=Final_shp, polName="Nickel")
Final_shp <- temp$existShp
polParameterList[[9]] <- temp$ml

```


```{r incase, eval=FALSE}
# meant Temperature
getmeanTemperature <- function(countryname)
{
stationInfo <- read.delim2(here::here("Paper","Covid19","CAUKIT","meanTemperature","stations.txt"), skip = 15, header = TRUE, sep = ",", dec = ",")

AlterID <- stationInfo$STAID[grep(countryname,stationInfo$COUNTRYNAME)]

txtNames <- list.files(here::here("Paper","Covid19","CAUKIT","meanTemperature"))
citytxtNames <- gsub("\\..*$", "",txtNames)
citytxtNames <- gsub("[a-zA-Z ]", "", citytxtNames)
citytxtNames <- as.numeric(citytxtNames)

cityIndex <- which(citytxtNames %in% AlterID)

readName <- paste0(here::here("Paper","Covid19","CAUKIT","meanTemperature/"),txtNames[cityIndex])

# https://www.ecad.eu/download/millennium/millennium.php
temperatureTxt <- lapply(readName, function(x)read.fwf(file=x,widths = c(6,6,rep(8,19)), na.strings='-999999', buffersize = 5, skip = 30))
temperatureTxt <- do.call('rbind',temperatureTxt)
temperatureTxt <- temperatureTxt %>% dplyr::select(V1:V3) %>% rename("STAID"="V1","Year"="V2","temp"="V3")%>% dplyr::filter(Year>=2016, Year<=2018, temp != -999999) %>% mutate(temp=0.01*temp)%>% group_by(STAID) %>% summarise(meanTemp=mean(temp,na.rm=T)) %>% dplyr::left_join(stationInfo, by="STAID")

temperatureTxt$LAT=as.numeric( str_sub(temperatureTxt$LAT,-2,-1))/3600+
 as.numeric( str_sub(temperatureTxt$LAT,-5,-4))/60+
  as.numeric( str_sub(temperatureTxt$LAT,2,-7))

temperatureTxt$LON=as.numeric( str_sub(temperatureTxt$LON,-2,-1))/3600+
 as.numeric( str_sub(temperatureTxt$LON,-5,-4))/60+
  as.numeric( str_sub(temperatureTxt$LON,2,-7))

return(temperatureTxt)
}

temperature_de <- getmeanTemperature("GERMANY")

getKrigingTemperatureforShp <- function(countyname, shortcode,existShp, polName)
{
  
##kriging
s100 <-  temperature_de%>% group_by(LON,LAT) %>% summarize(temperature=mean(meanTemp,na.rm=TRUE)) #duplicated coordinates
s100 <- as.geodata(s100)
# ml <- likfit(s100, ini = c(1,0.5), fix.nugget = T)
ml <- likfit(s100, ini = c(1,0.5), nug = 0.5)

cityPop <- raster::raster(here::here("Paper","Covid19","MedalComponents",paste0(shortcode,"_msk_pop"),paste0(tolower(shortcode), "_msk_pop")))
new.loc <- as.data.frame(coordinates(cityPop))
# kriging calculations
kc <- krige.conv(s100, loc = new.loc, krige = krige.control(obj.m = ml))
# displaying predicted values

lalala <- cbind(new.loc, value=kc$predict, inver_sd=1/(kc$krige.var))
# 
city <- map_data("world") %>% filter(region==countyname)
ggplot() +
    geom_polygon(data = city, aes(x=long, y = lat, group = group), fill="grey", alpha=0.3) +
    geom_point( data=lalala, aes(x=x, y=y, color=value)) +
    theme_void() + coord_map()

cityPop <- cityPop*lalala$inver_sd
PPmultiply <- cityPop*lalala$value

# get the grid within each prov
# shp <- raster::shapefile(here::here("Paper","Covid19","MedalComponents",paste0(shortcode,"_adm"),paste0(shortcode, "_adm2")))
rasterGrid_list <- vector(mode="list",length = length(existShp))

## Make Weather Station a Spatial Object
  weather_station <- coordinates(cityPop)
  weather_station <- as.data.frame(weather_station)
  colnames(weather_station) <- c('long','lat')
  coordinates(weather_station) <- c('long','lat')
projection(weather_station)="+init=epsg:4326" # code for lat-long

# get stations within Province
for(i in 1:length(rasterGrid_list))
{
  # Just try to make Toronto work 
  ## Projection and Buffer
  toronto = existShp[i,]
  ## Project weather station 
projection(toronto)=projection(weather_station) # everything is lat-long
insideTO = !is.na(over(weather_station, as(toronto,"SpatialPolygons")))
  rasterGrid_list[[i]] <- which(insideTO)
  print(i)
}

 # plot(shp[4,])
 # plot(weather_station[rasterGrid_list[[4]]], add=TRUE)

existShp@data$newVar <- NA
for(i in 1:length(rasterGrid_list))
{
existShp@data$newVar[i] <- 
sum(values(PPmultiply)[rasterGrid_list[[i]]]/sum(values(cityPop)[rasterGrid_list[[i]]],na.rm = TRUE),na.rm = T)
}
names(existShp@data)[length(names(existShp@data))] <- polName
####
return(list(existShp=existShp, ml=ml))
}


temp <- getKrigingTemperatureforShp(countyname="Germany", shortcode="DEU",existShp=Final_shp, polName="Temperature")

Final_shp <- temp$existShp
polParameterList[[10]] <- temp$ml

save(Final_shp, file=here::here("Paper","Covid19","Germany", "Final_shp.RData"))
save(polParameterList, file=here::here("Paper","Covid19","Germany", "polParameterList.RData"))
```


# Method {#sec:method}

Based on the observed and expected counts of disease cases occurring in each areal unit, we calculate SIR$_{k}=Y_{k}/E_{k}$, to measure the risk of disease. SIR$_{k}>1$ represents areas with elevated levels of disease risk, while SIR$_{k}<1$ corresponds to comparatively healthy areas. The elevated risks are likely to happen by chance if $E_{k}$ is small, which can occur if the disease in question is rare and/or the population at risk is small [@Lee2011]. To overcome this problem, the Poisson log-linear spatial models are typically used for the analysis [@Elliott2000; @Banerjee2004; @Lawson2008], where the linear predictor includes pollutant concentrations and potential confounders. These known covariates are augmented by a set of random effects to capture the residual spatial autocorrelation after the covariate effects have been accounted for. The random effects borrow strength from values in neighbouring areas, which reduces the likelihood of excesses in risk occurring by chance. 

These random effects are commonly modelled by the class of conditional autoregressive (CAR) prior distributions, which are a type of Markov random field model [@Rue2005]. The spatial correlation between the random effects is determined by a binary $K × K$ neighbourhood matrix \textbf{W}. Based on this neighbourhood matrix, the most common models for the random effects include intrinsic autoregressive [@Besag1991], convolution model [@Besag1991], as well as those proposed by @Cressie1993 and @Leroux1999. These CAR models differ by holding different assumptions about how the random effects depend on each other across space.   

## Pollution model

For simplicity, in this study we use a univariate model for each pollutant, since the number of monitoring stations is 709 which is a large sample size and produces predictions with modest standard errors. We treat the underlying pollution levels in Germany as a spatial Gaussian process $\{S(\symbf{s}):\symbf{s}\in \mathbb{R}^{2}\}$ with mean $\mu$, variance $\sigma^2=\mbox{Var}\{S(\symbf{s})\}$ and correlation function $\rho(u)= \mbox{Corr}\{S(\symbf{s}), S(\symbf{s}\prime)\}= \mbox{exp}(-u/\eta)$, where $u=\lVert \symbf{s}-\symbf{s}\prime\rVert$ denotes the Euclidean
distance between $\symbf{s}$ and $\symbf{s}\prime$. Denote the observed pollution data as $\symbf{Z}=\{Z(\symbf{s}); \symbf{s}= \symbf{s}_1,\dots,\symbf{s}_n\}$, and write $\symbf{S}=\{S(\symbf{s}); \symbf{s}= \symbf{s}_1,\dots,\symbf{s}_n\}$ for the unobserved values of the signal at the sampling locations $\symbf{s}_1,\dots,\symbf{s}_n$, the pollution model is assumed as
\begin{equation}
\symbf{Z} = \symbf{S} + \symbf{\epsilon},
\label{eq:model}
\end{equation}
where $\symbf{\epsilon} (\symbf{s}) \sim \mbox{N} (\symbf{0}, \tau^2\symbf{I})$ is uncorrelated with $\symbf{S}$, and $\symbf{I}$ is the identity matrix of order $n$. $\symbf{S}$ is multivariate Gaussian with mean vector $\mu \symbf{1}$, where $\symbf{1}$ denotes a vector each of whose elements is 1, and variance matrix $\tau^2 R$, where $R$ is the $n$ by $n$ matrix with elements $r_{ij}=\rho(\lVert \symbf{s}_i-\symbf{s}_j\prime\rVert)$. Similarly, $Z$ is multivariate Gaussian 
\begin{eqnarray}
\symbf{Z} &\sim& \mbox{N} (\mu\symbf{1}, \sigma^2 V)\\\nonumber
V &=&  R+\nu^2\symbf{I},
\label{eq:var}
\end{eqnarray}
where $\nu^2=\tau^2/\sigma^2$ is the noise-to-signal variance ratio. 

The log-likelihood function of (\ref{eq:model}) is 
\begin{eqnarray}
L(\mu, \tau^2,\sigma^2,\eta) = -0.5\{n\log(2\pi)+\log\{\mid \sigma^2 R(\eta)+\tau^2\symbf{I} \mid\}+(\symbf{Z}- \mu\symbf{1})\prime ( \sigma^2 R(\eta)+\tau^2\symbf{I})^{-1} (\symbf{Z} - \mu\symbf{1})\}
\label{eq:likelihood}
\end{eqnarray}

Given $V$, the maximum likelihood estimate (mle) of $\mu$ and $\sigma^2$ is given by,
\begin{eqnarray}
\hat{\mu} (V) &=& (\symbf{1}\prime V^{-1}\symbf{1})^{-1}\symbf{1}\prime V^{-1}\symbf{Z}\\\nonumber
\hat{\sigma}^2(V) &=& n^{-1}(\symbf{Z}- \hat{\mu}\symbf{1})\prime V^{-1} (\symbf{Z} - \hat{\mu}\symbf{1}).
\label{eq:gle}
\end{eqnarray}

By substituting $\hat{\mu} (V)$, and $\hat{\sigma}^2 (V)$ into the log-likelihood function, we have,
\begin{eqnarray}
L_0(\nu^2,\eta) = -0.5\{n\log(2\pi)+n\log \hat{\sigma}^2(V) + \log{\mid V\mid}+n\},
\label{eq:likelihood0}
\end{eqnarray}
which can be optimized numerically with respect to $\eta$ and $\nu$, followed by back substitution to obtain $\hat{\sigma}^2$ and $\hat{\mu}$. This is achieved by function **likfit()** in **geoR** package by providing initial values for the covariance parameters [@Diggle2007].

## Population-weighted exposure {#sec:weightedexposure}

The areal pollution exposure is estimated by aggregating the gridded predictions weighted by population density and also the precision of prediction. For a new location $\symbf{s}_0$, the Kriging formula of $S(\symbf{s}_0)$ [@Diggle2007] is used to obtain its prediction by plugging-in the resulting estimates $\hat{\mu}, \sigma^2, \hat{\tau}^2, \hat{\eta}$, which is
\begin{equation}
\hat{S}(\symbf{s}_0) = \hat{\mu}+ \symbf{C}\prime_{\symbf{s}_0} (\hat{\sigma}^2 \hat{V})^{-1}(\symbf{Z}-\hat{\mu}\symbf{1}),
\label{eq:prediction}
\end{equation}
where $\symbf{C}_{\symbf{s}_0}=\hat{\sigma}^2(\exp(-\|\symbf{s}_1-\symbf{s}_0\|/\hat{\eta}),\dots,\exp(-\|\symbf{s}_n-\symbf{s}_0\|/\hat{\eta}))\prime$.
The corresponding prediction variance is $\mbox{Var}(\hat{S}(\symbf{s}_0)-S(\symbf{s}_0))=\hat{\sigma}^2-\symbf{C}\prime_{\symbf{s}_0} (\hat{\sigma}^2 \hat{V})^{-1}\symbf{C}_{\symbf{s}_0}$, based on which we have the inverse variance for the prediction, 
$\zeta(\symbf{s}_0)=\frac{1}{\mbox{Var}(\hat{S}(\symbf{s}_0)-S(\symbf{s}_0))}$. The higher $\zeta(\symbf{s}_0)$ is, the better quality the prediction has, and we give more weight to the most reliably pollution values while aggregating them [@SanchezMeca1998; @LeeC2016]. 

After obtaining pollution predictions at the center of all grids where the population density data are available (see Figure \ref{fig:maps2}) using (\ref{eq:prediction}), by denoting the population density at location $\symbf{s}_i$ as $G(\symbf{s}_i)$, for a specific $k$ county, the spatially representative pollution concentration is estimated by 

\begin{equation}
z_k = \sum_{\symbf{s}_i \in A_k}\frac{\hat{S}(\symbf{s}_i)G(\symbf{s}_i)\zeta(\symbf{s}_i)}{\sum_{\symbf{s}_j \in A_k} G(\symbf{s}_j)\zeta(\symbf{s}_i)},
\label{eq:arealEstimate}
\end{equation}
where $A_k$ represents county $k$. Therefore, $z_k$ is a spatial metric of pollution concentrations weighted by population density and also the inverse of their Kriged variances. 


## Health model {#sec:healthModel}

Recalled that the disease data are counts of the numbers of cases occurring in each county in Germany, and the observed and expected number of COVID-19 cases for county $k$ are denoted as $Y_{k}$, $E_{k}$, respectively.  The health model is a Poisson log-linear model [see @Shaddick2015], given by 

 \begin{eqnarray}\label{eq:healthmodel}
Y_{k}  &\sim & \mbox{Poisson}(E_{k}\lambda_{k}),~~k=1,\ldots,K,\\\nonumber
\log(\lambda_{k}) &=& \symbf{X}_{k}^{\top}\symbf{\beta}+\phi_{k}
\end{eqnarray}
where the relative risk of disease in country $k$ is denoted by $\lambda_{k}$, and is modelled on the log scale by covariates $\symbf{X}_{k}$, containing an intercept column and covariates (pollutants, temperature and areal population density [population divided by area] referred to as popDensity), and a spatial random effect $\phi_{k}$. The regression parameters $\symbf{\beta}$ are assigned weakly informative zero-mean Gaussian priors with diagonal variance matrix $\symbf{\beta}\sim \mbox{N}\left(\symbf{0},10^2\symbf{I} \right)$. 

The spatial random effect, $\phi_{k}$, is included to allow for any residual spatial autocorrelation remaining in the disease counts after the covariate effects have been accounted for, and is modelled by,
\begin{eqnarray}\label{eq:model2}
\symbf{\phi} \sim \mbox{N}\left(\symbf{0},\kappa^2 \symbf{Q}(\xi,\symbf{W})^{-1}\right),
\end{eqnarray}
where $\symbf{\phi}=\{\phi_k, k=1,\dots, K\}$. Spatial autocorrelation is induced into the random effects by the precision matrix $\symbf{Q}(\xi,\symbf{W})=\xi(\mbox{diag}(\symbf{W}\symbf{1})-\symbf{W})+(1-\xi)\symbf{I}$, which corresponds to the CAR model proposed by @Leroux1999. The spatial dependence in the data is captured by an $K \times K$ neighbourhood matrix $\symbf{W}$, whose $ij$th element equals 1 if areas $(i,j )$ share a common border and is zero otherwise. The level of spatial autocorrelation in the random effects is controlled by $\xi$. Finally, weakly informative hyperpriors are specified for the parameters $(\kappa^2,\xi)$ by
\begin{eqnarray}\label{eq:model3}
\kappa &\sim &  \mbox{Exp}[\log(2)],\\\nonumber
\log(\frac{\xi}{1-\xi}) &\sim & \mbox{N}(0,1.8).
\end{eqnarray}
The prior distribution of $\xi$ is likely non-informative as it is roughly uniformly distributed within [0,1]. The prior distribution of $\kappa$ allows small values, which are what we expected for the variation of the log scale of relative risk. Health models are implemented in INLA which uses the Integrated Nested Laplace Approximation [@Rue2009], a computationally effective and extremely powerful alternative to implement Bayesian models, and is an increasingly popular analysis package in R. For details on how to fit spatial and spatio-temporal models with R-INLA, refer to @Blangiardo2013. 

# Results {#sec:results}

```{r modelReady, include=FALSE, message=FALSE, echo=FALSE}
library(spdep)
library(INLA) 

load(file=here::here("Paper","Covid19","Germany", "Final_shp.RData"))

W <- poly2nb(Final_shp) 
W.moran <- nb2listw(W,zero.policy = TRUE)
W <- nb2mat(W, style="B",zero.policy = TRUE)

model_data <- Final_shp@data
model_data$ID <- 1:nrow(model_data)
```

## Exposure estimation

Table \ref{tab:polParameter} presents the estimation of pollution model parameters while applying model (\ref{eq:model}) to different pollutants separately. The main message from the table is that the Akaike information criterion [AIC, @Akaike1973] from the proposed spatial pollution model (\ref{eq:model}) are all well less than those from non-spatial models (an intercept with independent errors, without spatial component $R$ in model (\ref{eq:var})), indicating the necessity of the spatial structure in pollution model. The main results from pollution model are the population-weighted county level exposure for each pollutant, with an example of NO$_2$ population-weighted exposure being shown in Figure \ref{fig:maps4} that the east part of Germany has much higher NO$_2$ exposure levels. A summary of the estimated population-weighted county level exposure is presented in Table \ref{tab:dataTable}, and an exploratory of the scatterplots of the natural logarithm of COVID-19 SIR against the population-weighted NO$_2$ and PM$_{2.5}$ are displayed in the upper of Figure \ref{fig:modelledposterior}, which appears to indicate a linear relationship between NO$_2$ and log COVID-19 SIR. 

```{r polParameter, results='asis', include=F}
library(kableExtra)
load(file=here::here("Paper","Covid19","Germany", "polParameterList.RData"))

# parTable <- t(mapply(function(x)
# {
#   cbind(x$beta,x$sigmasq,x$nugget,x$phi, summary(x)["likelihood"]$likelihood$AIC, summary(x)["ns.likelihood"]$ns.likelihood$AIC)
# },
# polParameterList, SIMPLIFY = TRUE
#   ))
# 
# save(parTable,file=here::here("Paper","Covid19","Germany", "parTable.RData"))
load(file=here::here("Paper","Covid19","Germany", "parTable.RData"))
parTable <- parTable[-4,] #delete ozone

rownames(parTable) <- c("NO2","PM25","PM10","SO2","Benzene","Aresenic","Cadmium","Nickel", "Temperature")
knitr::kable(parTable, "latex",digits = 3, linesep="", booktabs=TRUE,caption="Parameter estimation from pollution model (\\ref{eq:model}).",row.names = TRUE,col.names =c("$\\symbf{\\mu}$","$\\symbf{\\sigma^2}$","$\\symbf{\\tau^2}$","$\\symbf{\\eta}$","AIC","Non-spatial AIC"),escape = FALSE) %>% row_spec(0, bold = TRUE)
```


```{r dataTable,echo=FALSE, include=F}
load(file=here::here("Paper","Covid19","Germany", "Final_shp.RData"))
library(tidyverse)
library(kableExtra)
dataTable <- Final_shp@data 
dataTable <- dataTable %>% 
  dplyr::select(c("no2","pm25","pm10","Aresenic","Benzene","Cadmium","Nickel","so2","Temperature"))%>% tidyr::gather() %>% group_by(key) %>% summarise(
  min=min(value, na.rm=T),
  quantile25=quantile(value, c(0.25), na.rm = T),
  median=median(value, na.rm=T),
  mean=mean(value, na.rm=T),
  quantile75=quantile(value, c(0.75), na.rm = T),
  max=max(value, na.rm=T),
)
rownames(dataTable) <- dataTable$key
orderDataTable <- dataTable[c("no2","pm25","pm10","so2","Benzene","Aresenic","Cadmium","Nickel", "Temperature"),] %>% rename("Variable"="key")

kable(orderDataTable, "latex", linesep = "",digits = 2,booktabs=T, caption="Population-weighted county level exposure summary, with unit $\\mu g m^{-3}$ for NO$_2$, PM$_{25}$, PM$_{10}$, SO$_2$, Benzene; $ng m^{-3}$ for Aresenic, admium, Nickel; and $^{\\circ}C$  for temperature.") %>%
  row_spec(0, bold = TRUE) 

```

\begin{table}

\caption{\label{tab:polParameter}Parameter estimation from pollution model (\ref{eq:model}).}
\centering
\begin{tabular}[t]{lrrrrrr}
\toprule
\textbf{ } & \textbf{$\symbf{\mu}$} & \textbf{$\symbf{\sigma^2}$} & \textbf{$\symbf{\tau^2}$} & \textbf{$\symbf{\eta}$} & \textbf{AIC} & \textbf{Non-spatial AIC}\\
\midrule
NO$_2$ & 20.181 & 60.532 & 107.134 & 0.537 & 4501.620 & 4644.213\\
PM$_{2.5}$ & 10.395 & 1.156 & 1.525 & 0.736 & 741.625 & 771.677\\
PM$_{10}$ & 17.483 & 4.375 & 10.265 & 0.554 & 2138.916 & 2178.230\\
SO$_2$ & 1.507 & 0.751 & 0.115 & 0.681 & 301.668 & 365.301\\
Benzene & 0.846 & 0.022 & 0.093 & 1.584 & 96.896 & 107.443\\
Aresenic & 0.446 & 0.014 & 0.031 & 1.473 & -71.610 & -54.280\\
Cadmium & 0.110 & 0.001 & 0.002 & 1.159 & -532.236 & -499.639\\
Nickel & 1.468 & 0.532 & 1.239 & 0.922 & 603.834 & 631.438\\
Temperature & 9.810 & 1.527 & 0.245 & 0.857 & 1783.719 & 2175.323\\
\bottomrule
\end{tabular}
\end{table}

\begin{table}

\caption{\label{tab:dataTable}Population-weighted county level exposure summary, with unit $\mu g m^{-3}$ for NO$_2$, PM$_{25}$, PM$_{10}$, SO$_2$, Benzene; $ng m^{-3}$ for Aresenic, admium, Nickel; and $^{\circ}C$  for temperature.}
\centering
\begin{tabular}[t]{lrrrrrr}
\toprule
 & \textbf{Min} & \textbf{Quantile25} & \textbf{Median} & \textbf{Mean} & \textbf{Quantile75} & \textbf{Max}\\
\midrule
NO$_2$ & 12.57 & 18.79 & 21.62 & 23.03 & 26.86 & 36.54\\
PM$_{2.5}$ & 8.64 & 9.98 & 10.52 & 10.48 & 10.94 & 12.21\\
PM$_{10}$ & 14.48 & 16.84 & 17.74 & 17.74 & 18.57 & 21.07\\
SO$_2$ & 0.69 & 1.21 & 1.51 & 1.66 & 1.95 & 4.23\\
Benzene & 0.69 & 0.81 & 0.85 & 0.88 & 0.96 & 1.15\\
Aresenic & 0.32 & 0.40 & 0.44 & 0.45 & 0.50 & 0.67\\
Cadmium & 0.08 & 0.10 & 0.10 & 0.11 & 0.13 & 0.20\\
Nickel & 0.97 & 1.32 & 1.44 & 1.63 & 1.85 & 3.22\\
Temperature & 6.69 & 9.61 & 10.15 & 10.09 & 10.54 & 11.84\\
\bottomrule
\end{tabular}
\end{table}

## Health model validation

Before presenting the health effects results from health model (\ref{eq:healthmodel}), we assess the necessity of including spatial autocorrelation via the random effects model (\ref{eq:model2}) by fitting a simplified version of model (\ref{eq:healthmodel}) without spatial random effects term $\phi_k$. The residuals from this model show substantial spatial autocorrelation, with significant Moran's I statistics (see the middle of Figure \ref{fig:modelledposterior}) [@Moran1950]. The empirical semi-variogram of the residuals in Figure \ref{fig:modelledposterior4} shows that few points are lying outside the 95\% Monte Carlo simulation envelopes, suggesting strong spatial autocorrelation is remained in the residuals and including the spatial random effect term (\ref{eq:model2}) in health model is appropriate. 

## Pollution health effects

In this section, we present the air pollution health effects, which are the main results in this study. For comparison purposes, we show both the results from our employed health model with the @Leroux1999 CAR model to account for spatially correlated residuals (referred to as "Leroux"), and the results from other commonly used CAR models, including the intrinsic autoregressive proposed by @Besag1991 (referred to as "Besag"), convolution model also proposed by @Besag1991 (referred to as "BYM"), and also the non-spatial model (referred to as "IID"). In addition, as PM$_{10}$ and PM$_{2.5}$ are highly correlated (with correlation coefficient being 0.75 in our study), we run two separated health model to avoid collinearity, with each model including either PM$_{10}$ or PM$_{2.5}$ and all the other covariates. The results from having PM$_{2.5}$ in the model are presented in this section in Table \ref{tab:monitoringModel}, while those from having PM$_{10}$ are presented in the Appendix in Table \ref{tab:monitoringModelpm10}. 

The bottom of Figure \ref{fig:modelledposterior} shows both the prior and posterior distributions of the spatial dependence parameter $\xi$ and variance parameter $\kappa$ from fitting the health model (\ref{eq:healthmodel}) (having PM$_{2.5}$), respectively, suggesting that both of them are well estimated from the data. Figure \ref{fig:modelledposterior5} shows that the estimate of $\xi$ is around 0.8 which indicates high spatial autocorrelation in the disease data after the covariate effects have been accounted for, validating the use of the spatial random effects model (\ref{eq:model2}). Similarly, Figure \ref{fig:modelledposterior6} shows the estimate of the spatial variance parameter $\kappa$ is around 0.75. The predicted COVID-19 SIR presented in Figure \ref{fig:modelledSIR1} from health model (\ref{eq:healthmodel}) shows that the majority of the high‐risk counties are at the east and south part of Germany, that is where the counties likely to have high probabilities of excess risk (see Figure \ref{fig:modelledSIR2}). 

The main results are presented in Table \ref{tab:monitoringModel}, including the posterior medians and 95% credible intervals of relative risk from one-unit increase for each covariate, and the widely applicable information criterion (WAIC) [@Watanabe2010] from fitting various health models, including the employed Leroux model, and commonly used BYM, Besag, IID models. Table \ref{tab:monitoringModel} shows that the WAIC from different CAR models are similar, while it is slightly lower (better) from the currently used Leroux model. The results from Leroux model show that NO$_2$ is significantly (at 0.05 level) associated with the COVID-19 SIR, with 1 $\mu gm^{-3}$ increase of long-term exposure to NO$_2$, the COVID-19 incidence rate is likely to increase `r substring(resultTable[1,1], 3, 6)`\% (95% CI: `r substring(resultTable[1,2], 3, 7)`\%, `r substring(resultTable[1,2], 11, 15)`\%). This statistically significant association between NO$_2$ and COVID-19 SIR is consistent across various health models, including the BYM, Besag, IID models (and also those from Table \ref{tab:monitoringModelpm10} where health model has PM$_{10}$ rather than PM$_{2.5}$), which enhances the plausibility of the results. 

The areal population density dose not have a significant association with COVID-19 SIR, while temperature displays a negative association (at 0.05 level) with COVID-19 incidence rate. As shown in Figure \ref{fig:maps3}, the COVID-19 SIRs are generally higher in the south where actually has a lower long-term temperature surface compared to the north [see @mapsofworld2020]. This explains the negative association between temperature and COVID-19 incidence rate. No substantial associations (at 0.05 level) were found between COVID-19 incidence rate and the other pollutants, including PM$_{2.5}$, SO$_2$, Benzene, Aresenic, Cadmium and Nickel. Note that SO$_2$ is just at the border of having a significant association with COVID-19 SIR, since the posterior probabilities of its increasing relative risk is 0.96 (see Table \ref{tab:monitoringModel}). And SO$_2$ is significantly associated with COVID-19 SIR from the model having PM$_{10}$ rather than PM$_{2.5}$ (see the Leroux model results from Table \ref{tab:monitoringModelpm10}). 
 
```{r monitoringModel, include=F}
library(INLA)
library(kableExtra)
library(dplyr)
spatialModel_SIR <- vector(mode = "list", length = 4)

prior <- list(
    theta1 = list(
        prior = "pc.prec",
        param = c(1, 0.5)),
    theta2 = list(
        prior = "gaussian",
        param = c(0, 1.8))
)

spatialModel_SIR[[1]] <- inla(cumul_cases ~ no2+pm25+so2+Temperature+scale(Benzene)+scale(Aresenic)+scale(Cadmium)+scale(Nickel)+scale(popDensity)+f(ID, model = 'besagproper2', graph = W, hyper = prior), E = E, family = 'poisson', data = model_data
                    ,control.compute = list(config=TRUE,dic = TRUE, waic = TRUE)
                    ,control.predictor = list(compute = TRUE))
spatialModel_SIR[[2]] <- inla(cumul_cases ~ no2+pm25+so2+Temperature+scale(Benzene)+scale(Aresenic)+scale(Cadmium)+scale(Nickel)+scale(popDensity)+f(ID, model = 'bym', graph = W), E = E, family = 'poisson', data = model_data
                    ,control.compute = list(config=TRUE,dic = TRUE, waic = TRUE)
                    ,control.inla = list(h=0.00001)
                    ,control.predictor = list(compute = TRUE))
spatialModel_SIR[[3]] <- inla(cumul_cases ~ no2+pm25+so2+Temperature+scale(Benzene)+scale(Aresenic)+scale(Cadmium)+scale(Nickel)+scale(popDensity)+f(ID, model = 'besag', graph = W), E = E, family = 'poisson', data = model_data
                    ,control.compute = list(config=TRUE,dic = TRUE, waic = TRUE)
                    ,control.predictor = list(compute = TRUE))
spatialModel_SIR[[4]] <- inla(cumul_cases ~ no2+pm25+so2+Temperature+scale(Benzene)+scale(Aresenic)+scale(Cadmium)+scale(Nickel)+scale(popDensity)+f(ID, model = 'iid', graph = W), E = E, family = 'poisson', data = model_data
                    ,control.compute = list(config=TRUE,dic = TRUE, waic = TRUE)
                    ,control.predictor = list(compute = TRUE))

performanceTable <- mapply(function(x){round(x$waic$waic,2)}, spatialModel_SIR, SIMPLIFY = T)

resultTable <- mapply(function(x){round(cbind(100*(exp(x$summary.fixed[-1,c(grep("0.5quant", names(x$summary.fixed)),grep("0.025|0.975", names(x$summary.fixed))),])-1),
                                              1- mapply(function(xx){inla.pmarginal(0,xx)}, x$marginals.fixed, SIMPLIFY =T)[-1]
),2)[,-1]}, spatialModel_SIR, SIMPLIFY = F)

resultTable <- mapply(function(x){
  characterTable <- NULL
for(i in 1:(ncol(x)-1))
{
    characterTable <- cbind(characterTable,str_pad(sprintf("%.2f",round(x[,i],2)),6,pad=" "))
}
   characterTable <- cbind(characterTable,str_pad(sprintf("%.2f",round(x[,ncol(x)],2)),3,pad=" "))
   
 cbind(characterTable[,1], paste0("(",characterTable[,2],", ",characterTable[,3],")"), paste0("[",characterTable[,4],"]"))
  
},resultTable)

resultTable <- matrix(resultTable, nrow = 9)

resultTable <- rbind(resultTable, as.character(c("", performanceTable[1],"","",performanceTable[2],"","",performanceTable[3],"","",performanceTable[4],"")))

rownames(resultTable) <- NULL
rownames(resultTable) <- c("NO2","PM25","SO2","Temperature","Benzene","Aresenic","Cadmium","Nickel", "popDensity","WAIC")


# colnames(resultTable) <- c("Leroux", "BYM","Besag","IID")

save(resultTable, file=here::here("Paper","Covid19","Germany", "resultTable.RData"))

kable(resultTable, "latex", align=c("rlcrlcrlcrlc"),linesep = "",booktabs=T,escape = FALSE, caption="Posterior medians and 95\\% CI for the relative risk (\\%) from one-unit increase in each covariate, and the WAIC from fitting various health models (having PM$_{2.5}$), including the employed Leroux model, and commonly used BYM, Besag, IID models. Pr is the posterior probabilities that covariate increases relative risk.") %>% 
  kable_styling(font_size = 9) %>% 
  add_header_above(c(" ", rep(c("Est","CI","Pr"),4))) %>%
  add_header_above(c(" ", "Leroux"=3, "BYM"=3,"Besag"=3,"IID"=3), bold = T) %>%
 landscape() 
```

\newgeometry{left=3.5cm}

\begin{landscape}\begin{table}

\caption{\label{tab:monitoringModel}Posterior medians and 95\% CI for the relative risk (\%) from one-unit increase in each covariate, and the WAIC from fitting various health models (having PM$_{2.5}$), including the employed Leroux model, and commonly used BYM, Besag, IID models. Pr is the posterior probabilities that covariate increases relative risk.}
\centering
\fontsize{9}{11}\selectfont
\begin{tabular}[t]{lrlcrlcrlcrlc}
\toprule
\multicolumn{1}{c}{\textbf{ }} & \multicolumn{3}{c}{\textbf{Leroux}} & \multicolumn{3}{c}{\textbf{BYM}} & \multicolumn{3}{c}{\textbf{Besag}} & \multicolumn{3}{c}{\textbf{IID}} \\
\cmidrule(l{3pt}r{3pt}){2-4} \cmidrule(l{3pt}r{3pt}){5-7} \cmidrule(l{3pt}r{3pt}){8-10} \cmidrule(l{3pt}r{3pt}){11-13}
\multicolumn{1}{c}{ } & \multicolumn{1}{c}{Est} & \multicolumn{1}{c}{CI} & \multicolumn{1}{c}{Pr} & \multicolumn{1}{c}{Est} & \multicolumn{1}{c}{CI} & \multicolumn{1}{c}{Pr} & \multicolumn{1}{c}{Est} & \multicolumn{1}{c}{CI} & \multicolumn{1}{c}{Pr} & \multicolumn{1}{c}{Est} & \multicolumn{1}{c}{CI} & \multicolumn{1}{c}{Pr} \\
\cmidrule(l{3pt}r{3pt}){2-2} \cmidrule(l{3pt}r{3pt}){3-3} \cmidrule(l{3pt}r{3pt}){4-4} \cmidrule(l{3pt}r{3pt}){5-5} \cmidrule(l{3pt}r{3pt}){6-6} \cmidrule(l{3pt}r{3pt}){7-7} \cmidrule(l{3pt}r{3pt}){8-8} \cmidrule(l{3pt}r{3pt}){9-9} \cmidrule(l{3pt}r{3pt}){10-10} \cmidrule(l{3pt}r{3pt}){11-11} \cmidrule(l{3pt}r{3pt}){12-12} \cmidrule(l{3pt}r{3pt}){13-13}
NO$_2$ & 5.58 & (  3.35,   7.86) & [1.00] & 5.21 & (  2.98,   7.50) & [1.00] & 5.36 & (  3.06,   7.71) & [1.00] & 5.60 & (  3.94,   7.29) & [1.00]\\
PM$_{2.5}$ & 4.59 & (-12.57,  24.79) & [0.69] & 1.62 & (-15.76,  22.51) & [0.57] & 0.45 & (-17.49,  22.27) & [0.52] & 8.04 & ( -2.70,  19.94) & [0.93]\\
SO$_2$ & 15.83 & ( -1.42,  35.45) & [0.96] & 6.29 & ( -9.20,  24.36) & [0.78] & 5.45 & (-10.56,  24.31) & [0.74] & 39.51 & ( 26.44,  53.94) & [1.00]\\
Temperature & -11.72 & (-20.84,  -1.46) & [0.01] & -8.52 & (-18.01,   2.05) & [0.05] & -8.48 & (-18.23,   2.41) & [0.06] & -18.12 & (-24.55, -11.16) & [0.00]\\
Benzene & -1.21 & (-19.21,  20.12) & [0.45] & -2.75 & (-23.00,  22.75) & [0.41] & -3.45 & (-24.59,  23.58) & [0.39] & 9.32 & ( -1.58,  21.41) & [0.95]\\
Aresenic & -16.72 & (-31.45,   1.67) & [0.04] & -9.34 & (-26.32,  11.47) & [0.17] & -10.27 & (-27.89,  11.64) & [0.16] & -22.38 & (-30.83, -12.92) & [0.00]\\
Cadmium & 16.44 & ( -5.67,  44.53) & [0.92] & 23.93 & ( -1.12,  55.49) & [0.97] & 27.08 & (  0.21,  61.15) & [0.98] & 6.86 & ( -5.49,  20.80) & [0.86]\\
Nickel & -1.35 & (-13.13,  12.03) & [0.42] & -1.41 & (-13.44,  12.26) & [0.41] & -1.56 & (-14.22,  12.95) & [0.41] & -1.47 & ( -8.90,   6.57) & [0.35]\\
popDensity & -2.12 & ( -7.34,   3.39) & [0.22] & -2.23 & ( -7.37,   3.19) & [0.20] & -1.83 & ( -6.98,   3.61) & [0.25] & -6.15 & (-11.35,  -0.65) & [0.01]\\
WAIC &  & 3814.64 &  &  & 3814.8 &  &  & 3816.18 &  &  & 3815.05 & \\
\bottomrule
\end{tabular}
\end{table}
\end{landscape}
\restoregeometry

# Discussion {#sec:conclusion}

"Poisoning our environment means poisoning our own body, and when it experiences chronic respiratory stress its ability to defend itself from infections is limited" [@Ogen2020]. Given that the existing research has linked pollutants (e.g., PM$_{2.5}$ and NO$_2$) exposure to health damage, particularly respiratory and lung diseases, which could make people more vulnerable to contracting COVID-19. This study uses a spatial ecological design to estimate the impacts of air pollution on COVID-19 infection in Germany by comparing geographical contrasts in air pollution and infection risk across $K$ contiguous small areas, where we use population-weighted method to better estimate the real areal pollution concentrations. The results show that long-term exposure to NO$_2$ is significantly associated with COVID-19 incidence rate in Germany, with 1 $\mu gm^{-3}$ increase of long-term exposure to NO$_2$, the COVID-19 incidence rate is likely to increase `r substring(resultTable[1,1], 3, 6)`\% (95% CI: `r substring(resultTable[1,2], 3, 7)`\%, `r substring(resultTable[1,2], 11, 15)`\%). No substantial associations were found between COVID-19 incidence rate and the other pollutants, including PM$_{2.5}$, PM$_{10}$, SO$_2$, Benzene, Aresenic, Cadmium and Nickel. Temperature and population density are adjusted in the model, and a set of random effects are also included to capture the residual spatial autocorrelation after the covariate effects have been accounted for. 

For comparison purposes, we also run the health models with other commonly used CAR models, including the intrinsic autoregressive proposed by @Besag1991, convolution model also proposed by @Besag1991, and also the non-spatial IID model. In addition, as PM$_{2.5}$ and PM$_{10}$ are highly correlated, we run two separated health models to avoid collinearity, with each model including either PM$_{2.5}$ or PM$_{10}$ and all the other covariates. We found that the statistically significant associations between NO$_2$ and COVID-19 SIR are consistent across these various health models, which enhances the plausibility of the results.

Several limitations to this pilot study need to be acknowledged. First, due to data availability, no socioeconomic or health care related covariates were included in the health model which, if included, would provide the possibility of sensitivity analyses and help testing the robustness of the findings. However, in our health model, we do include a spatial random effects term to allow for any spatial autocorrelation residuals after accounting for the known covariates, and the main findings of NO$_2$ are actually adjusted for a set of other pollutants and temperature. Another limitation is lacking COVID-19 testing numbers, since the confirmed cases (positive testing numbers) in a county mainly rely on the total testing numbers being conducted in that county, without which the infection rates in some counties could be higher or lower estimated compared to others'. Therefore, we put an effort to better estimate the expected cases in each county by utilizing national sex-age standardized infection rate. The limitation in regard to pollution model is that the current one is a univariate model, which is potentially losing some power by not borrowing strength over correlated pollutants compared to a multivariate pollution model. 

Finally, besides COVID-19 infection rate, its death rate and multi-country studies should also be focused when (or if) more deaths occur in the future. Such studies will help us better understanding COVID-19, and also help the global community and health organizations stay informed and make data driven decisions.

```{r modelledposterior, echo=FALSE,message=FALSE ,results = FALSE,warning=FALSE, fig.cap="Upper: scatterplots of log COVID-19 SIR against NO$_2$ ($\\mu gm^{-3}$) and PM$_{2.5}$ ($\\mu gm^{-3}$); Middle: the Moran's I test and the empirical semi-variogram of the residuals from the non-spatial health model (circles), with 95\\% Monte Carlo simulation envelopes (dashed lines); Bottom: posterior (solid line) and prior (dashed line) plots for $\\xi$ and $\\kappa$ from health model (\\ref{eq:healthmodel}).",fig.subcap=c("NO$_2$","PM$_{2.5}$", "Moran's I test, p-value<0.0001","Empirical semi-variogram", "$\\xi$","$\\kappa$"), fig.width=6, fig.height=3, out.width=Pmisc::out.width(0.5), dev='pdf'}

load(file=here::here("Paper","Covid19","Germany", "Final_shp.RData"))
Final_shp@data %>% mutate(logSIR=log(cumul_cases/E), SIR=cumul_cases/E)->Final_shp@data

Final_shp@data$logSIR_fitted <- log(spatialModel_SIR[[1]]$summary.fitted.values$mean)
Final_shp@data$SIR_residuals <- Final_shp@data$logSIR - Final_shp@data$logSIR_fitted


plot(Final_shp$no2,log(Final_shp$cumul_cases/Final_shp$E),xlab="", ylab="log(SIR)")
plot(Final_shp$pm25,log(Final_shp$cumul_cases/Final_shp$E),xlab="", ylab="log(SIR)")

library(geoR)
glmModel_SIR <- glm(cumul_cases ~ no2+pm25+so2+Temperature+scale(Benzene)+scale(Aresenic)+scale(Cadmium)+scale(Nickel)+scale(popDensity), offset = log(E), family = 'poisson', data = as.data.frame(model_data))

moranData <- as.geodata(data.frame(coordinates(Final_shp),glmModel_SIR$residuals))

set.seed(126)
moranMCMC <- moran.mc(glmModel_SIR$residuals, W.moran, nsim=10000)
moranPvalue <- moranMCMC$p.value
plot(moranMCMC, main="",xlab="",xlim=c(-0.15, 0.6))

s100.vario <- variog(moranData, max.dist=50)
s100.env <- variog.mc.env(moranData, obj.var = s100.vario)
plot(s100.vario, envelope = s100.env)


data=rnorm(1000000, 0,1.8)
data=exp(data)/(exp(data)+1)
data <- density(data, from=0, to=1)
data$y[1] <- 0
data$y[length(data$y)] <- 0

temp <- spatialModel_SIR[[1]]$marginals.hyperpar$`Lambda for ID`
temp[1,1] <- 0
temp[nrow(temp),1] <- 1

plot(temp, type="l", xlim=c(0,1),xlab="", ylab=expression(tilde(p)(paste(xi,"|",Y))))
lines(data, lty=3)



pcprecden <- function(x){inla.pc.dprec(x, u=1, alpha=0.5)}
x <- c(seq(0,4,by=0.001))

prec_post <- spatialModel_SIR[[1]]$marginals.hyperpar$`Precision for ID`
temp <- rbind(c(0,0), inla.tmarginal(function(x) 1/(x^{1/2}),prec_post),c(3,0))

plot.default(temp,
             type="l",xlim=c(0,3),xlab="",
             ylab=expression(tilde(p)(paste(kappa,"|",Y))))
lines(x, inla.pc.dprec(prec=x, u=1, alpha=0.5), lty=3, xlim=c(0,3))

```

```{r modelledSIR, fig.cap="Posterior means of relative risk E$(\\lambda_k|Y)$ and probabilities of excess risk Pr$(\\exp(\\phi_i)> 1.5 \\mid Y)$.",fig.subcap=c("Predicted risk ","Exceedance probabilities"), fig.width=8, fig.height=6, out.width=Pmisc::out.width(0.5), dev='pdf'}

Final_shp@data$Rhat <- spatialModel_SIR[[1]]$summary.fitted.values$mean
# spplot(Final_shp, "Rhat",col="transparent",col.regions=gray.colors(20, start = 0.9, end = 0.3, gamma = 2.2, alpha = NULL),
#        colorkey = list(labels = list( cex = 1.5)))

Final_shp@data$Rhatcut <-  cut(Final_shp@data$Rhat, breaks=c(0,0.5,1,1.5,3,5,9), include.lowest = T)
library(RColorBrewer)
pal <- brewer.pal(7, "OrRd") # we select 7 colors from the palette
 
spplot(Final_shp, "Rhat", col.regions= gray.colors(20, start = 0.9, end = 0.1, gamma = 1.1, alpha = NULL), col="transparent", colorkey = list(labels = list( cex = 1.5)))

csi <- spatialModel_SIR[[1]]$marginals.random$ID[1: length(Final_shp)]
 a <- log(1.5)
 prob.csi <- lapply(csi, function(x) {1 - inla.pmarginal(a, x)})

 Final_shp@data$randomP <- unlist(prob.csi)
 
 Final_shp@data$randomPcut <- cut(Final_shp@data$randomP, breaks=c(0,0.3,0.5,0.8,0.95,1), include.lowest = T)
 
spplot(Final_shp, "randomP", col.regions= gray.colors(20, start = 0.9, end = 0.1, gamma = 1.1, alpha = NULL), col="transparent", colorkey = list(labels = list( cex = 1.5)))

# breaks <- c(0,0.5,1,1.5,2,3,5,8,12)
# breakLevels <- levels(cut(breaks, breaks, include.lowest = TRUE))
# cols <- RColorBrewer::brewer.pal(8, "Greys")
# 
# caCol <- mapmisc::colourScale(
#   Final_shp$Rhat, breaks = breaks, col = cols, style='fixed',
#   dec=1)
# caCol$breaks <- format(caCol$breaks, nsmall=1)
# 
# # plot maps
# legendCex <- 0.7
# 
# plot(Final_shp, col=caCol$plot, border='grey', lwd=0.02)
# mapmisc::legendBreaks('topright', caCol, bty='n', inset=c(0.23,0.75), cex=legendCex)
# 
# #### randomP
# theCol = mapmisc::colourScale(Final_shp$randomP, breaks=9, style='equal', dec=1, col = cols)
# plot(Final_shp, col=theCol$plot, border='grey', lwd=0.01)
#  mapmisc::legendBreaks('topright', theCol, bty='n', inset=c(0.23,0.75), cex=legendCex)

```


# Appendix {-} 

The results from fitting health models having PM$_{10}$ are shown in Table \ref{tab:monitoringModelpm10}. The raw data and R code used in this study will be shared on Github shortly.   


```{r monitoringModelpm10, include=F}
library(INLA)
library(kableExtra)
spatialModel_SIR <- vector(mode = "list", length = 4)

prior <- list(
    theta1 = list(
        prior = "pc.prec",
        param = c(1, 0.5)),
    theta2 = list(
        prior = "gaussian",
        param = c(0, 1.8))
)

spatialModel_SIR[[1]] <- inla(cumul_cases ~ no2+pm10+so2+Temperature+scale(Benzene)+scale(Aresenic)+scale(Cadmium)+scale(Nickel)+scale(popDensity)+f(ID, model = 'besagproper2', graph = W, hyper = prior), E = E, family = 'poisson', data = model_data
                    ,control.compute = list(config=TRUE,dic = TRUE, waic = TRUE)
                    ,control.predictor = list(compute = TRUE))
spatialModel_SIR[[2]] <- inla(cumul_cases ~ no2+pm10+so2+Temperature+scale(Benzene)+scale(Aresenic)+scale(Cadmium)+scale(Nickel)+scale(popDensity)+f(ID, model = 'bym', graph = W), E = E, family = 'poisson', data = model_data
                    ,control.compute = list(config=TRUE,dic = TRUE, waic = TRUE)
                    ,control.inla = list(h=0.00001)
                    ,control.predictor = list(compute = TRUE))
spatialModel_SIR[[3]] <- inla(cumul_cases ~ no2+pm10+so2+Temperature+scale(Benzene)+scale(Aresenic)+scale(Cadmium)+scale(Nickel)+scale(popDensity)+f(ID, model = 'besag', graph = W), E = E, family = 'poisson', data = model_data
                    ,control.compute = list(config=TRUE,dic = TRUE, waic = TRUE)
                    ,control.predictor = list(compute = TRUE))
spatialModel_SIR[[4]] <- inla(cumul_cases ~ no2+pm10+so2+Temperature+scale(Benzene)+scale(Aresenic)+scale(Cadmium)+scale(Nickel)+scale(popDensity)+f(ID, model = 'iid', graph = W), E = E, family = 'poisson', data = model_data
                    ,control.compute = list(config=TRUE,dic = TRUE, waic = TRUE)
                    ,control.predictor = list(compute = TRUE))

performanceTable <- mapply(function(x){round(x$waic$waic,2)}, spatialModel_SIR, SIMPLIFY = T)

resultTable <- mapply(function(x){round(cbind(100*(exp(x$summary.fixed[-1,c(grep("0.5quant", names(x$summary.fixed)),grep("0.025|0.975", names(x$summary.fixed))),])-1),
                                              1- mapply(function(xx){inla.pmarginal(0,xx)}, x$marginals.fixed, SIMPLIFY =T)[-1]
),2)[,-1]}, spatialModel_SIR, SIMPLIFY = F)

resultTable <- mapply(function(x){
  characterTable <- NULL
for(i in 1:(ncol(x)-1))
{
    characterTable <- cbind(characterTable,str_pad(sprintf("%.2f",round(x[,i],2)),6,pad=" "))
}
   characterTable <- cbind(characterTable,str_pad(sprintf("%.2f",round(x[,ncol(x)],2)),3,pad=" "))
   
 cbind(characterTable[,1], paste0("(",characterTable[,2],", ",characterTable[,3],")"), paste0("[",characterTable[,4],"]"))
  
},resultTable)

resultTable <- matrix(resultTable, nrow = 9)

resultTable <- rbind(resultTable, as.character(c("", performanceTable[1],"","",performanceTable[2],"","",performanceTable[3],"","",performanceTable[4],"")))

rownames(resultTable) <- NULL
rownames(resultTable) <- c("NO2","PM25","SO2","Temperature","Benzene","Aresenic","Cadmium","Nickel", "popDensity","WAIC")


# colnames(resultTable) <- c("Leroux", "BYM","Besag","IID")

# save(resultTable, file=here::here("Paper","Covid19","Germany", "resultTable.RData"))

kable(resultTable, "latex", align=c("rlcrlcrlcrlc"),linesep = "",booktabs=T,escape = FALSE, caption="Posterior medians and 95\\% CI for the relative risk (\\%) from one-unit increase in each covariate, and the WAIC from fitting various health models (having PM$_{2.5}$), including the employed Leroux model, and commonly used BYM, Besag, IID models. Pr is the posterior probabilities that covariate increases relative risk.") %>% 
  kable_styling(font_size = 9) %>% 
  add_header_above(c(" ", rep(c("Est","CI","Pr"),4))) %>%
  add_header_above(c(" ", "Leroux"=3, "BYM"=3,"Besag"=3,"IID"=3), bold = T) %>% 
 landscape() 
```

\newgeometry{left=3.5cm}

\begin{landscape}\begin{table}

\caption{\label{tab:monitoringModelpm10}Posterior medians and 95\% CI for the relative risk (\%) from one-unit increase in each covariate, and the WAIC from fitting various health models (having PM$_{2.5}$), including the employed Leroux model, and commonly used BYM, Besag, IID models. Pr is the posterior probabilities that covariate increases relative risk.}
\centering
\fontsize{9}{11}\selectfont
\begin{tabular}[t]{lrlcrlcrlcrlc}
\toprule
\multicolumn{1}{c}{\textbf{ }} & \multicolumn{3}{c}{\textbf{Leroux}} & \multicolumn{3}{c}{\textbf{BYM}} & \multicolumn{3}{c}{\textbf{Besag}} & \multicolumn{3}{c}{\textbf{IID}} \\
\cmidrule(l{3pt}r{3pt}){2-4} \cmidrule(l{3pt}r{3pt}){5-7} \cmidrule(l{3pt}r{3pt}){8-10} \cmidrule(l{3pt}r{3pt}){11-13}
\multicolumn{1}{c}{ } & \multicolumn{1}{c}{Est} & \multicolumn{1}{c}{CI} & \multicolumn{1}{c}{Pr} & \multicolumn{1}{c}{Est} & \multicolumn{1}{c}{CI} & \multicolumn{1}{c}{Pr} & \multicolumn{1}{c}{Est} & \multicolumn{1}{c}{CI} & \multicolumn{1}{c}{Pr} & \multicolumn{1}{c}{Est} & \multicolumn{1}{c}{CI} & \multicolumn{1}{c}{Pr} \\
\cmidrule(l{3pt}r{3pt}){2-2} \cmidrule(l{3pt}r{3pt}){3-3} \cmidrule(l{3pt}r{3pt}){4-4} \cmidrule(l{3pt}r{3pt}){5-5} \cmidrule(l{3pt}r{3pt}){6-6} \cmidrule(l{3pt}r{3pt}){7-7} \cmidrule(l{3pt}r{3pt}){8-8} \cmidrule(l{3pt}r{3pt}){9-9} \cmidrule(l{3pt}r{3pt}){10-10} \cmidrule(l{3pt}r{3pt}){11-11} \cmidrule(l{3pt}r{3pt}){12-12} \cmidrule(l{3pt}r{3pt}){13-13}
NO$_2$ & 6.06 & (  3.50,   8.67) & [1.00] & 5.51 & (  2.91,   8.20) & [1.00] & 5.57 & (  2.94,   8.26) & [1.00] & 6.93 & (  5.02,   8.88) & [1.00]\\
PM$_{10}$ & -2.98 & (-12.49,   7.63) & [0.28] & -1.43 & (-11.56,   9.81) & [0.40] & -1.61 & (-11.78,   9.72) & [0.38] & -7.88 & (-14.13,  -1.17) & [0.01]\\
SO$_2$ & 18.82 & (  0.90,  39.05) & [0.98] & 6.40 & ( -9.64,  25.21) & [0.77] & 6.18 & ( -9.94,  25.18) & [0.76] & 50.66 & ( 37.18,  65.45) & [1.00]\\
Temperature & -10.89 & (-20.34,  -0.24) & [0.02] & -8.09 & (-18.09,   3.13) & [0.07] & -8.05 & (-18.12,   3.24) & [0.08] & -16.21 & (-22.97,  -8.87) & [0.00]\\
Benzene & -0.80 & (-18.69,  20.39) & [0.47] & -3.00 & (-23.67,  23.12) & [0.40] & -3.27 & (-24.07,  23.22) & [0.39] & 8.46 & ( -2.34,  20.43) & [0.94]\\
Aresenic & -13.74 & (-29.20,   5.35) & [0.07] & -9.18 & (-26.99,  12.85) & [0.19] & -9.42 & (-27.34,  12.88) & [0.19] & -12.82 & (-22.89,  -1.44) & [0.01]\\
Cadmium & 13.52 & ( -8.03,  41.21) & [0.88] & 25.46 & ( -0.87,  59.05) & [0.97] & 26.31 & ( -0.47,  60.27) & [0.97] & -1.37 & (-12.55,  11.21) & [0.41]\\
Nickel & -0.70 & (-12.51,  12.67) & [0.46] & -1.32 & (-13.82,  12.95) & [0.42] & -1.37 & (-14.00,  13.11) & [0.42] & -1.17 & ( -8.59,   6.85) & [0.38]\\
popDensity & -2.08 & ( -7.30,   3.43) & [0.22] & -1.92 & ( -7.09,   3.52) & [0.24] & -1.82 & ( -6.98,   3.61) & [0.25] & -5.89 & (-11.08,  -0.41) & [0.02]\\
WAIC &  & 3814.55 &  &  & 3815.65 &  &  & 3816.13 &  &  & 3814.58 & \\
\bottomrule
\end{tabular}
\end{table}
\end{landscape}
\restoregeometry
     
<!-- ##############################################################################      -->
<!-- ##############################################################################      -->
     
<!-- \newgeometry{left=1.1cm} -->

```{r dataSourceTable, include=F}
library(kableExtra)
dataSource <- data.frame(Source=c("Federal Agency for Cartography and Geodesy",
                                # "Kaggle: Heads or Tails",
                                "Robert Koch Institute",
                                "National Platform for Geographic Data",
                                "Federal Office for Statistics: Statistisches Bundesamt",
                                "Open Data platform GENESIS",
                                "City Population",
                                "DIVA-GIS",
                                "European Environment Agency: Air Quality e-Reporting"
                                ),
                         Link=c("https://www.bkg.bund.de/EN/Home/home.html",
                                # "https://www.kaggle.com/headsortails/covid19-tracking-germany",
                                "https://www.rki.de/EN/Home/homepage_node.html",
                                "https://npgeo-corona-npgeo-de.hub.arcgis.com/",
                                "https://www.destatis.de/EN/Home/_node.html",
                                "https://www-genesis.destatis.de/genesis/online",
                                "https://www.citypopulation.de/en/germany/admin/",
                                "https://www.diva-gis.org/gdata",
                                "https://www.eea.europa.eu/"
                                )
                           )

kable(dataSource, "latex", caption = "Publicly available data sources used in the analysis.") %>% kable_styling() %>% row_spec(0, bold = T)

```
<!-- \restoregeometry  -->